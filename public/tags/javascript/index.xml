<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pinggod · VENI VIDI VICI</title>
    <link>http://pinggod.com/tags/javascript/index.xml</link>
    <description>Recent content on Pinggod · VENI VIDI VICI</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <atom:link href="http://pinggod.com/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>函数式编程术语解析</title>
      <link>http://pinggod.com/post/abc/</link>
      <pubDate>Sun, 06 Nov 2016 15:05:27 +0800</pubDate>
      
      <guid>http://pinggod.com/post/abc/</guid>
      <description>

&lt;p&gt;函数式编程蔚然成风，越来越多的开源项目、技术交流在使用函数式编程的术语降低开发或沟通成本，这无形中对不了解函数式编程的开发者造成了一定的学习门槛，翻译本文的初衷就是要普及函数式编程的基本知识，从新的角度扩展编程思维。至于为什么要使用 JavaScript 演示函数式编程，一方面是因为 JavaScript 的特性在很多方面与函数式编程浑然天成，另一方面是因为 JavaScript 是世界上最 XX 的语言……&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;arity&#34;&gt;Arity&lt;/h2&gt;

&lt;p&gt;指函数的参数数量，由 &lt;code&gt;-ary&lt;/code&gt; 和 &lt;code&gt;-ity&lt;/code&gt; 这两个英文后缀拼接而成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const sum = (a, b) =&amp;gt; a + b;

const arity = sum.length;
console.log(arity); 
// =&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;higher-order-functions&#34;&gt;Higher-Order Functions&lt;/h2&gt;

&lt;p&gt;高阶函数，此类函数可以接收其他函数作为参数，也可以返回一个函数作为返回值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const filter = (pred, xs) =&amp;gt; {
    const result = [];
    for (let idx = 0; idx &amp;lt; xs.length; idx++) {
        if (pred(xs[idx])) {
            result.push(xs[idx]);
        }
    }
    return result;
};

const is = (type) =&amp;gt; (x) =&amp;gt; Object(x) instanceof type;

filter(is(Number), [0, &#39;1&#39;, 2, null]); 
// =&amp;gt; [0, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;partial-application&#34;&gt;Partial Application&lt;/h2&gt;

&lt;p&gt;偏函数，在原函数的基础上预填充（pre-filling）部分参数并返回的新函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 下面是一个创建偏函数的辅助函数
const partial = (f, ...args) =&amp;gt; (...moreArgs) =&amp;gt; f(...args, ...moreArgs);

const add3 = (a, b, c) =&amp;gt; a + b + c;

// 预填充 (add3, 2, 3) 三个参数，空置最后一个参数，返回一个新的函数
const fivePlus = partial(add3, 2, 3); // (c) =&amp;gt; 2 + 3 + c

fivePlus(4); 
// =&amp;gt; 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript 中的 &lt;code&gt;Function.prototype.bind()&lt;/code&gt; 函数是创建偏函数的最简单方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const add1More = add3.bind(null, 2, 3); 
// =&amp;gt; (c) =&amp;gt; 2 + 3 + c
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;currying&#34;&gt;Currying&lt;/h2&gt;

&lt;p&gt;柯里化，将一个接收多个参数的函数转化为单参数函数的方式，转化后的函数每次只接收一个参数，然后返回一个新函数，新函数可以继续接收参数，直到接收到所有的参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const sum = (a, b) =&amp;gt; a + b;

sum(2, 3)
// =&amp;gt; 6

const curriedSum = (a) =&amp;gt; (b) =&amp;gt; a + b;

curriedSum(40)(2) 
// =&amp;gt; 42.

const add2 = curriedSum(2); 
// (b) =&amp;gt; 2 + b

add2(10) 
// =&amp;gt; 12
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;function-composition&#34;&gt;Function Composition&lt;/h2&gt;

&lt;p&gt;函数合成，接收多个函数作为参数并返回一个新函数的方式，新函数按照传入的参数顺序，从右往左依次执行，前一个函数的返回值是后一个函数的输入值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const compose = (f, g) =&amp;gt; (a) =&amp;gt; f(g(a))

const floorAndToString = compose((val) =&amp;gt; val.toString(), Math.floor)

floorAndToString(121.212121) 
// =&amp;gt; &amp;quot;121&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;purity&#34;&gt;Purity&lt;/h2&gt;

&lt;p&gt;一个纯函数需要满足两个条件，第一是函数的返回值只能由输入值（函数接收的参数）决定，也就是说纯函数接收相同的参数会返回相同的值；第二是纯函数不会对自身作用域之外的运行环境产生副作用（side effects），比如说不会改变外部环境中变量的值，这会被认为是不安全的行为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let greeting;
const greet = () =&amp;gt; greeting = &amp;quot;Hi, &amp;quot; + window.name;

// greet() 执行时更改了外部环境的变量
greet(); 
// =&amp;gt; &amp;quot;Hi, Brianne&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;纯函数示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const greet = (name) =&amp;gt; &amp;quot;Hi, &amp;quot; + name ;

greet(&amp;quot;Brianne&amp;quot;) 
// =&amp;gt; &amp;quot;Hi, Brianne&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;side-effects&#34;&gt;Side effects&lt;/h2&gt;

&lt;p&gt;如果函数或表达式与其自身作用域之外的可变数据（mutable data）发生了读写操作，那么此时函数和表达式就产生了副作用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let greeting;
const greet = () =&amp;gt; greeting = &amp;quot;Hi, &amp;quot; + window.name;

// greet() 执行时更改了外部环境的变量
greet(); 
// =&amp;gt; &amp;quot;Hi, Brianne&amp;quot;

// new Date() 是可变数据
const differentEveryTime = new Date();

// 这里表示系统接收到的输入值是不确定的，是一种可变数据
console.log(&amp;quot;IO is a side effect!&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;idempotent&#34;&gt;Idempotent&lt;/h2&gt;

&lt;p&gt;幂等，同一个函数使用相同的参数嵌套执行多次的结果与执行一次的结果相同:&lt;/p&gt;

&lt;p&gt;$$f(&amp;hellip;f(f(x))&amp;hellip;)=f(x)$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Math.abs(Math.abs(10))

sort(sort(sort([2,1])))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;point-free-style&#34;&gt;Point-Free Style&lt;/h2&gt;

&lt;p&gt;point-free style 是一种不显式向函数传递参数的代码风格，通常需要柯里化和高阶函数来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const map = (fn) =&amp;gt; (list) =&amp;gt; list.map(fn);
const add = (a) =&amp;gt; (b) =&amp;gt; a + b;

// Not points-free
// numbers 是一个显式传递的参数
const incrementAll = (numbers) =&amp;gt; map(add(1))(numbers);

// Points-free
// add(1) 的返回值隐式传递给了 map，作为 map 的 list 参数
const incrementAll2 = map(add(1));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;point-free style 的函数看起来就像是一个赋值表达式，没有使用我们常见的 &lt;code&gt;function&lt;/code&gt; 或 &lt;code&gt;=&amp;gt;&lt;/code&gt; 等来声明其接收的参数。&lt;/p&gt;

&lt;h2 id=&#34;predicate&#34;&gt;Predicate&lt;/h2&gt;

&lt;p&gt;断言，一个返回布尔值的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const predicate = (a) =&amp;gt; a &amp;gt; 2;

[1, 2, 3, 4].filter(predicate); 
// =&amp;gt; [3, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;contracts&#34;&gt;Contracts&lt;/h2&gt;

&lt;p&gt;TODO&lt;/p&gt;

&lt;h2 id=&#34;guarded-functions&#34;&gt;Guarded Functions&lt;/h2&gt;

&lt;p&gt;TODO&lt;/p&gt;

&lt;h2 id=&#34;categories&#34;&gt;Categories&lt;/h2&gt;

&lt;p&gt;categories 内部都绑定了具体的函数用于约束或执行特定的逻辑，比如 Monoid。&lt;/p&gt;

&lt;h2 id=&#34;value&#34;&gt;Value&lt;/h2&gt;

&lt;p&gt;任何可以赋值给变量的值都可以称为 &lt;code&gt;value&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;5
Object.freeze({name: &#39;John&#39;, age: 30}) // The `freeze` function enforces immutability.
(a) =&amp;gt; a
[1]
undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;constant&#34;&gt;Constant&lt;/h2&gt;

&lt;p&gt;常量，初始化后不能再次执行赋值操作的数据类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const five = 5
const john = { name: &#39;John&#39;, age: 30 }

// 因为常量不可变，所以下面表达式一定为 true
john.age + five === ({ name: &#39;John&#39;, age: 30 }).age + (5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常量具有 referentially transparent 的特性，也就是说将程序中出现的常量替换为它们实际的值，并不会影响程序的结果。译者话外：实际上在 JavaScript 中的 &lt;code&gt;const&lt;/code&gt; 所声明的常量并不是完全稳定的，使用 Immutable.js 演示更加恰当：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const five = fromJS(5);
const john = fromJS({name: &#39;John&#39;, age: 30})

john.get(&#39;age&#39;) + five === ({ name: &#39;John&#39;, age: 30 }).age + (5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;f(g()) === g&lt;/p&gt;

&lt;h2 id=&#34;functor&#34;&gt;Functor&lt;/h2&gt;

&lt;p&gt;functor 都拥有 &lt;code&gt;map&lt;/code&gt; 函数，并且在执行 &lt;code&gt;map&lt;/code&gt; 之后会返回一个新的 functor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;object.map(x =&amp;gt; x) === object

object.map(x =&amp;gt; f(g(x))) === object.map(g).map(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript 中最常见的 functor 就是数组类型的实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;[1, 2, 3].map(x =&amp;gt; x); 
// =&amp;gt; [1, 2, 3]

const f = x =&amp;gt; x + 1;
const g = x =&amp;gt; x * 2;

[1, 2, 3].map(x =&amp;gt; f(g(x))); 
// =&amp;gt; [3, 5, 7]
[1, 2, 3].map(g).map(f);     
// =&amp;gt; [3, 5, 7]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pointed-functor&#34;&gt;Pointed Functor&lt;/h2&gt;

&lt;p&gt;pointed functor 都拥有 &lt;code&gt;of&lt;/code&gt; 函数，用于接收和构建 functor。ES2015 提供了 &lt;code&gt;Array.of&lt;/code&gt; 函数，所以数组实例就可以看成是 pointed functor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Array.of(1) 
// =&amp;gt; [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lift&#34;&gt;Lift&lt;/h2&gt;

&lt;p&gt;lift 发生在你将值放入 functor 的时候，如果你将函数 lift 进了 Applicative Functor，那么就可以使用这个函数处理传递给这个 functor 的值。某些 lift 的实现拥有 lift 或 liftA2 函数，便于在 functor 上执行相关的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const mult = (a, b) =&amp;gt; a * b;

const liftedMult = lift(mult); 
// =&amp;gt; this function now works on functors like array

liftedMult([1, 2], [3]); 
// =&amp;gt; [3, 6]
lift((a, b) =&amp;gt; a + b)([1, 2], [3, 4]); 
// =&amp;gt; [4, 5, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lift 一个单参数的函数非常类似于 &lt;code&gt;map&lt;/code&gt; 操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const increment = (x) =&amp;gt; x + 1;

lift(increment)([2]); 
// =&amp;gt; [3]
[2].map(increment); 
// =&amp;gt; [3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;referential-transparency&#34;&gt;Referential Transparency&lt;/h2&gt;

&lt;p&gt;如果一个表达式可以被替换为实际的值而不影响程序的运行结果，那么我们就说这个表达式是 referentially transparent：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const greet = () =&amp;gt; &amp;quot;Hello World!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上面代码为例，任何调用 &lt;code&gt;greet()&lt;/code&gt; 的地方都可以替换为 &lt;code&gt;&amp;quot;Hello World!&amp;quot;&lt;/code&gt; 而不影响程序的执行结果。&lt;/p&gt;

&lt;h2 id=&#34;equational-reasoning&#34;&gt;Equational Reasoning&lt;/h2&gt;

&lt;p&gt;如果一个应用由多个表达式组合而成，且每个表达式都没有 side effect，那么这个应用就可以由部分推导出整体。&lt;/p&gt;

&lt;h2 id=&#34;lambda&#34;&gt;Lambda&lt;/h2&gt;

&lt;p&gt;匿名函数，本质上是一个 value：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function(a){
    return a + 1;
};

(a) =&amp;gt; a + 1;

// Lambda 常用语高阶函数中
[1, 2].map((a) =&amp;gt; a + 1); 
// = [2, 3]

// Lambda 作为 value 被赋值给变量
let addOne = (a) =&amp;gt; a + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lambda-calculus&#34;&gt;Lambda Calculus&lt;/h2&gt;

&lt;p&gt;数学的分支之一，使用函数创建通用的计算模型（&lt;a href=&#34;https://en.wikipedia.org/wiki/Lambda_calculus&#34; target=&#34;_blank&#34;&gt;universal model of computation&lt;/a&gt;）。&lt;/p&gt;

&lt;h2 id=&#34;lazy-evaluation&#34;&gt;Lazy evaluation&lt;/h2&gt;

&lt;p&gt;惰性求值，是一种按需执行的求值策略，只有需要某个值时才会执行相关的表达式。在函数式编程语言中，这一特性可用于构造无限列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const rand = function*() {
    while (true) {
        yield Math.random();
    }
}

const randIter = rand();
randIter.next().value; 
// 每次执行 next() 函数都会返回一个新的随机数
// 有且只有在执行 next() 的时候才会返回新值
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;monoid&#34;&gt;Monoid&lt;/h2&gt;

&lt;p&gt;Monoid，通过一个函数“合并”两个同类型数据后返回相同的数据类型。最简单的 monoid 就是两数相加：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;1 + 1; 
// =&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的 &lt;code&gt;+&lt;/code&gt; 就是上面所说的“合并”函数。Monoid 中存在恒等式的概念：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;1 + 0
// =&amp;gt; 1
// 这里的 0 就是恒等式

// Monoid 还必须满足结合律
1 + (2 + 3) === (1 + 2) + 3; 
// =&amp;gt; true

// 数组的 concat() 操作可以构造一个 monoid
[1, 2].concat([3, 4]); 
// =&amp;gt; [1, 2, 3, 4]

// 空数组可以视为是恒等式
[1, 2].concat([]); 
// =&amp;gt; [1, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果知道了一个函数的的恒等式和“合并”函数 compose，函数本身就是一个 monoid:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const identity = (a) =&amp;gt; a;
const compose = (f, g) =&amp;gt; (x) =&amp;gt; f(g(x));

compose(foo, identity) ≍ compose(identity, foo) ≍ foo
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;monad&#34;&gt;Monad&lt;/h2&gt;

&lt;p&gt;Monad，是一个拥有 &lt;code&gt;of&lt;/code&gt; 和 &lt;code&gt;chain&lt;/code&gt; 函数的数据类型，&lt;code&gt;chain&lt;/code&gt; 类似于 &lt;code&gt;map&lt;/code&gt;，但它会输出非嵌套形式的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;[&#39;cat,dog&#39;, &#39;fish,bird&#39;].chain((a) =&amp;gt; a.split(&#39;,&#39;)) 
// =&amp;gt; [&#39;cat&#39;, &#39;dog&#39;, &#39;fish&#39;, &#39;bird&#39;]

[&#39;cat,dog&#39;, &#39;fish,bird&#39;].map((a) =&amp;gt; a.split(&#39;,&#39;)) 
// =&amp;gt; [[&#39;cat&#39;, &#39;dog&#39;], [&#39;fish&#39;, &#39;bird&#39;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在其他函数式编程语言中，&lt;code&gt;of&lt;/code&gt; 也被称为 &lt;code&gt;return&lt;/code&gt;，&lt;code&gt;chain&lt;/code&gt; 也被称为 &lt;code&gt;flatmap&lt;/code&gt; 和 &lt;code&gt;bind&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;comonad&#34;&gt;Comonad&lt;/h2&gt;

&lt;p&gt;Comonad，拥有 &lt;code&gt;extract&lt;/code&gt; 和 &lt;code&gt;extend&lt;/code&gt; 函数的数据类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const CoIdentity = (v) =&amp;gt; ({
    val: v,
    extract() { return this.val },
    extend(f) { return CoIdentity(f(this)) }
})

// extract() 可以从 functor 中取值
CoIdentity(1).extract() 
// =&amp;gt; 1

// extend() 可以返回新的 comonad
CoIdentity(1).extend(co =&amp;gt; co.extract() + 1) 
// =&amp;gt; CoIdentity(2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;applicative-functor&#34;&gt;Applicative Functor&lt;/h2&gt;

&lt;p&gt;Applicative Functor，是拥有 &lt;code&gt;ap&lt;/code&gt; 函数的数据类型，&lt;code&gt;ap&lt;/code&gt; 函数可以将 functor 中的值转化为其他 functor 中的同类型值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;[(a) =&amp;gt; a + 1].ap([1]) 
// =&amp;gt; [2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一特性对于多个 applicative functor 需要接收多个参数时，就显得很有用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const arg1 = [1, 2];
const arg2 = [3, 4];
const add = (x) =&amp;gt; (y) =&amp;gt; x + y;

const partiallyAppliedAdds = [add].ap(arg1); 
// =&amp;gt; [(y) =&amp;gt; 1 + y, (y) =&amp;gt; 2 + y]

partiallyAppliedAdds.ap(arg2); 
// =&amp;gt; [4, 5, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;morphism&#34;&gt;Morphism&lt;/h2&gt;

&lt;p&gt;态射，一个转换函数。&lt;/p&gt;

&lt;h2 id=&#34;isomorphism&#34;&gt;Isomorphism&lt;/h2&gt;

&lt;p&gt;同构转换，相同数据下不同结构之间的转换。举例来说，2D 坐标既可以存储为数组 &lt;code&gt;[2, 3]&lt;/code&gt; 也可以存储为 &lt;code&gt;{ x: 2, y: 3 }&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const pairToCoords = (pair) =&amp;gt; ({x: pair[0], y: pair[1]})
const coordsToPair = (coords) =&amp;gt; [coords.x, coords.y]

coordsToPair(pairToCoords([1, 2])) 
// =&amp;gt; [1, 2]

pairToCoords(coordsToPair({x: 1, y: 2})) 
// =&amp;gt; { x: 1, y: 2 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;setoid&#34;&gt;Setoid&lt;/h2&gt;

&lt;p&gt;Setoid，拥有 &lt;code&gt;equals&lt;/code&gt; 函数的数据类型，可用于与其他同类型的数据进行比较。为 Array 类型添加 &lt;code&gt;equals&lt;/code&gt; 函数使其成为 Setoid：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Array.prototype.equals = (arr) =&amp;gt; {
    const len = this.length
    if (len !== arr.length) {
        return false
    }
    for (let i = 0; i &amp;lt; len; i++) {
        if (this[i] !== arr[i]) {
            return false
        }
    }
    return true
}

[1, 2].equals([1, 2]) 
// =&amp;gt; true
[1, 2].equals([0]) 
// =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;semigroup&#34;&gt;Semigroup&lt;/h2&gt;

&lt;p&gt;Semigroup，拥有 &lt;code&gt;concat&lt;/code&gt; 函数的数据类型，可以与同类型数据进行合并：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;[1].concat([2]) 
// =&amp;gt; [1, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;foldable&#34;&gt;Foldable&lt;/h2&gt;

&lt;p&gt;Foldable，拥有 &lt;code&gt;reduce&lt;/code&gt; 函数的数据类型，可以将 Foldable 的实例转换为其他数据类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const sum = (list) =&amp;gt; list.reduce((acc, val) =&amp;gt; acc + val, 0);
sum([1, 2, 3]) 
// =&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;traversable&#34;&gt;Traversable&lt;/h2&gt;

&lt;p&gt;TODO&lt;/p&gt;

&lt;h2 id=&#34;type-signatures&#34;&gt;Type Signatures&lt;/h2&gt;

&lt;p&gt;类型签名，在 JavaScript 中通常会在注释中写明当前函数的参数类型和返回值类型，虽然各种语言的类型签名不同，但通常与以下示例相似：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// functionName :: firstArgType -&amp;gt; secondArgType -&amp;gt; returnType

// add :: Number -&amp;gt; Number -&amp;gt; Number
const add = (x) =&amp;gt; (y) =&amp;gt; x + y

// increment :: Number -&amp;gt; Number
const increment = (x) =&amp;gt; x + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果某个函数要作为参数传递给其他函数，那么在类型签名中需要使用括号包裹起这个函数的类型信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// call :: (a -&amp;gt; b) -&amp;gt; a -&amp;gt; b
const call = (f) =&amp;gt; (x) =&amp;gt; f(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面示例中的 &lt;code&gt;a&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt; 表示参数可以是任何数据类型的，但在下面的代码中，&lt;code&gt;map&lt;/code&gt; 的类型签名表示: f 是一个函数，f 接收一个 a 类型的参数，返回一个 b 类型的值，同时 map 是一个柯里化的函数，其第二个接收一个列表形式的 a 类型参数，并返回列表形式的 b 类型参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]
const map = (f) =&amp;gt; (list) =&amp;gt; list.map(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;union-type&#34;&gt;Union type&lt;/h2&gt;

&lt;p&gt;联合类型，表示将多个类型信息放入一个类型变量中。JavaScript 中没有类型机制，所以让我们假设有一个类型变量 &lt;code&gt;NumOrString&lt;/code&gt;，它表示 Number 或者 String 类型。&lt;code&gt;+&lt;/code&gt; 运算符在 JavaScript 中既可用于 Number，也可用于 String，所以我们使用 &lt;code&gt;NumOrString&lt;/code&gt; 定义 &lt;code&gt;+&lt;/code&gt; 的输入输出类型信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// add :: (NumOrString, NumOrString) -&amp;gt; NumOrString
const add = (a, b) =&amp;gt; a + b;

add(1, 2); 
// =&amp;gt; Number 3
add(&#39;Foo&#39;, 2); 
// =&amp;gt; String &amp;quot;Foo2&amp;quot;
add(&#39;Foo&#39;, &#39;Bar&#39;); 
// =&amp;gt; String &amp;quot;FooBar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;product-type&#34;&gt;Product type&lt;/h2&gt;

&lt;p&gt;product type 同样包含多种基本类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// point :: (Number, Number) -&amp;gt; {x: Number, y: Number}
const point = (x, y) =&amp;gt; ({x: x, y: y});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;option&#34;&gt;Option&lt;/h2&gt;

&lt;p&gt;Option，是 union type 的特例，它只包含两种类型 &lt;code&gt;Some&lt;/code&gt; 和 &lt;code&gt;None&lt;/code&gt;。Option 常用于表示那些不确定是否返回值的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Naive definition
const Some = (v) =&amp;gt; ({
    val: v,
    map(f) {
        return Some(f(this.val));
    },
    chain(f) {
        return f(this.val);
    }
});

const None = () =&amp;gt; ({
    map(f){
        return this;
    },
    chain(f){
        return this;
    }
});

// maybeProp :: (String, {a}) -&amp;gt; Option a
const maybeProp = (key, obj) =&amp;gt; typeof obj[key] === &#39;undefined&#39; ? None() : Some(obj[key]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;chain&lt;/code&gt; 函数执行链式调用可以返回具体的 &lt;code&gt;Option&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// getItem :: Cart -&amp;gt; Option CartItem
const getItem = (cart) =&amp;gt; maybeProp(&#39;item&#39;, cart);

// getPrice :: Item -&amp;gt; Option Number
const getPrice = (item) =&amp;gt; maybeProp(&#39;price&#39;, item);

// getNestedPrice :: cart -&amp;gt; Option a
const getNestedPrice = (cart) =&amp;gt; getItem(obj).chain(getPrice);

getNestedPrice({}); 
// =&amp;gt; None()
getNestedPrice({item: {foo: 1}}); 
// =&amp;gt; None()
getNestedPrice({item: {price: 9.99}}); 
// =&amp;gt; Some(9.99)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;某些语言中使用 &lt;code&gt;Maybe&lt;/code&gt; 表示 &lt;code&gt;Option&lt;/code&gt;，使用 &lt;code&gt;Just&lt;/code&gt; 表示 &lt;code&gt;Some&lt;/code&gt;，使用 &lt;code&gt;Nothing&lt;/code&gt; 表示 &lt;code&gt;Node&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>